#!/usr/bin/env python3
"""Transform Widdershins/Slate-flavored markdown to MkDocs-compatible format.

This script processes API documentation generated by Widdershins and transforms it
to work properly with MkDocs Material theme, including:
- Cleaning Slate-specific front-matter
- Converting HTML headers to markdown
- Creating tabbed code blocks
- Converting aside elements to admonitions
"""

import re
import sys
from pathlib import Path


def clean_front_matter(content: str) -> str:
    """Remove Slate-specific front-matter fields, keep only title."""
    # Match YAML front matter
    match = re.match(r"^---\n(.*?)\n---\n", content, re.DOTALL)
    if not match:
        return content

    # Extract just the title line from the front matter
    front_matter = match.group(1)
    title_match = re.search(r"^title:\s*(.+)$", front_matter, re.MULTILINE)

    if title_match:
        title = title_match.group(1)
        # Create clean front matter with just the title
        new_front_matter = f"---\ntitle: {title}\n---\n"
    else:
        # No title found, use minimal front matter
        new_front_matter = "---\ntitle: API Documentation\n---\n"

    # Replace old front matter with new
    return content.replace(match.group(0), new_front_matter)


def remove_html_comments(content: str) -> str:
    """Remove HTML comments like <!-- Generator: Widdershins -->."""
    return re.sub(r"<!--.*?-->", "", content, flags=re.DOTALL)


def convert_html_headers_to_markdown(content: str) -> str:
    """Convert HTML header tags to markdown headers."""
    # Process h1 through h6
    for level in range(1, 7):
        pattern = rf"<h{level}[^>]*>(.*?)</h{level}>"
        replacement = "#" * level + r" \1"
        content = re.sub(pattern, replacement, content, flags=re.MULTILINE)
    return content


def remove_anchor_tags(content: str) -> str:
    """Remove standalone HTML anchor tags."""
    # Remove <a id="..."></a> tags
    return re.sub(r'<a id="[^"]*"></a>\n?', "", content)


def transform_code_samples_to_tabs(content: str) -> str:
    """Transform sequential code blocks into MkDocs tabbed format."""

    def create_tabs(match):
        """Convert matched code samples block to tabbed format."""
        code_blocks_text = match.group(1)

        # Extract individual code blocks with their language
        block_pattern = r"```(\w+)\n(.*?)\n```"
        blocks = re.findall(block_pattern, code_blocks_text, re.DOTALL)

        if not blocks:
            return match.group(0)  # Return original if no blocks found

        # Create tabbed format
        tabs = []
        for lang, code in blocks:
            # Capitalize language name for tab title
            lang_title = lang.capitalize()
            if lang == "javascript":
                lang_title = "JavaScript"
            elif lang == "python":
                lang_title = "Python"
            elif lang == "curl":
                lang_title = "cURL"

            # Create tab with proper indentation
            tab = f'=== "{lang_title}"\n\n    ```{lang}\n'

            # Indent code by 4 spaces
            indented_lines = []
            for line in code.split("\n"):
                if line:  # Don't add extra spaces to empty lines
                    indented_lines.append("    " + line)
                else:
                    indented_lines.append("")

            tab += "\n".join(indented_lines)
            tab += "\n    ```\n"
            tabs.append(tab)

        return "\n".join(tabs)

    # Pattern: > Code samples followed by language-specific code blocks
    # Match the blockquote and all following code blocks
    pattern = r"> Code samples\n\n((?:```\w+\n.*?\n```\n*)+)"

    return re.sub(pattern, create_tabs, content, flags=re.DOTALL)


def convert_asides_to_admonitions(content: str) -> str:
    """Convert HTML aside elements to MkDocs admonitions."""

    def create_admonition(match):
        """Convert matched aside to admonition format."""
        admon_type = match.group(1)  # success, warning, note, etc.
        text = match.group(2).strip()

        # Indent text for admonition body
        indented_lines = []
        for line in text.split("\n"):
            if line.strip():  # Only indent non-empty lines
                indented_lines.append("    " + line)
            else:
                indented_lines.append("")

        indented_text = "\n".join(indented_lines)

        return f"!!! {admon_type}\n{indented_text}"

    # Pattern: <aside class="TYPE">Text</aside>
    pattern = r'<aside class="(\w+)">\n(.*?)\n</aside>'

    return re.sub(pattern, create_admonition, content, flags=re.DOTALL)


def clean_whitespace(content: str) -> str:
    """Clean up excessive whitespace."""
    # Remove more than 2 consecutive newlines
    content = re.sub(r"\n{3,}", "\n\n", content)
    # Ensure file ends with single newline
    return content.rstrip() + "\n"


def transform_widdershins_to_mkdocs(content: str) -> str:
    """Apply all transformations to convert Widdershins output to MkDocs format."""
    content = clean_front_matter(content)
    content = remove_html_comments(content)
    content = convert_html_headers_to_markdown(content)
    content = remove_anchor_tags(content)
    content = transform_code_samples_to_tabs(content)
    content = convert_asides_to_admonitions(content)
    content = clean_whitespace(content)
    return content


def main():
    """Main entry point for the script."""
    if len(sys.argv) != 3:
        print("Usage: transform_api_docs.py <input_file> <output_file>")
        sys.exit(1)

    input_file = Path(sys.argv[1])
    output_file = Path(sys.argv[2])

    if not input_file.exists():
        print(f"Error: Input file not found: {input_file}")
        sys.exit(1)

    # Read input file
    content = input_file.read_text()

    # Transform content
    transformed = transform_widdershins_to_mkdocs(content)

    # Write output file
    output_file.write_text(transformed)

    print(f"Transformed {input_file} -> {output_file}")


if __name__ == "__main__":
    main()
