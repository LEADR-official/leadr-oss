#!/usr/bin/env python3
"""Split griffe2md-generated Python reference documentation into multiple files by module.

This script takes a single reference.md file generated by griffe2md and splits it
into separate files based on top-level modules (e.g., leadr.accounts, leadr.auth).
It also rewrites internal links to maintain navigation between the split files.
"""

import re
import sys
from pathlib import Path


def slugify(text: str) -> str:
    """Convert module name to a URL-friendly filename."""
    # For module names like "leadr.accounts", extract just "accounts"
    if text.startswith("leadr."):
        text = text[6:]  # Remove "leadr." prefix
    # Remove special characters and convert to lowercase
    slug = re.sub(r"[^\w\s-]", "", text.lower())
    # Replace spaces and dots with hyphens
    return re.sub(r"[-.\s]+", "-", slug).strip("-")


def extract_module_name(text: str) -> str:
    """Extract clean module name from header text."""
    # Remove markdown formatting, HTML tags, and code blocks
    clean = re.sub(r"[`*_]", "", text)
    clean = re.sub(r"<[^>]+>", "", clean)
    return clean.strip()


def parse_modules(content: str) -> tuple[str, list[tuple[str, str, str]]]:
    """Parse the markdown into header/intro and module sections.

    Returns:
        Tuple of (front_matter_and_intro, list of (module_name, slug, content) tuples)
    """
    # Split content by H3 headers (### leadr.module)
    # The structure is: ## leadr (top package), then ### leadr.accounts, ### leadr.auth, etc.
    lines = content.split("\n")
    intro_lines = []
    modules = []
    current_module = None
    current_module_name = None
    current_content = []

    for line in lines:
        # Match H3 headers (### leadr.module)
        h3_match = re.match(r"^###\s+(.+)$", line)

        if h3_match:
            # Save previous module
            if current_module and current_content:
                modules.append((
                    current_module_name,
                    slugify(current_module),
                    "\n".join(current_content)
                ))

            # Start new module (this is a top-level submodule like leadr.accounts)
            current_module = extract_module_name(h3_match.group(1))
            current_module_name = current_module
            current_content = [line]
        elif current_module:
            # We're inside a module section
            current_content.append(line)
        else:
            # Still in intro section (before first H3)
            intro_lines.append(line)

    # Save last module
    if current_module and current_content:
        modules.append((
            current_module_name,
            slugify(current_module),
            "\n".join(current_content)
        ))

    intro = "\n".join(intro_lines)
    return intro, modules


def build_anchor_map(
    modules: list[tuple[str, str, str]]
) -> dict[str, tuple[str, str]]:
    """Build a map of anchor IDs to (filename, anchor) for link rewriting.

    Returns:
        Dict mapping anchor_id -> (target_file, anchor_in_file)
    """
    anchor_map = {}

    for module_name, slug, content in modules:
        filename = f"{slug}.md"

        # Track all identifiers that start with this module name
        # e.g., "leadr.accounts", "leadr.accounts.domain", etc.

        # Find all headers (H3-H7) and potential anchor points
        # Since we're splitting at H3, we look for H3 and deeper
        for match in re.finditer(r"^#{3,7}\s+`?([^`\n]+?)`?\s*$", content, re.MULTILINE):
            identifier = extract_module_name(match.group(1))

            # Add both the full identifier and just the anchor form
            anchor_map[identifier] = (filename, identifier)

            # Also add slug version
            anchor_slug = slugify(identifier)
            anchor_map[anchor_slug] = (filename, identifier)

    return anchor_map


def rewrite_links(content: str, anchor_map: dict[str, tuple[str, str]]) -> str:
    """Rewrite internal markdown links to point to the correct files.

    Converts links like [text](#leadr.module.Class) to [text](./module.md#leadr.module.Class)
    """
    def replace_link(match):
        link_text = match.group(1)
        link_target = match.group(2)

        # Skip if it's not an anchor link
        if not link_target.startswith("#"):
            return match.group(0)

        # Remove the # prefix
        anchor_id = link_target[1:]

        # Look up in anchor map (try both with and without backticks)
        clean_anchor = re.sub(r"`", "", anchor_id)

        if clean_anchor in anchor_map:
            target_file, target_anchor = anchor_map[clean_anchor]
            if target_anchor:
                return f"[{link_text}](./{target_file}#{target_anchor})"
            else:
                return f"[{link_text}](./{target_file})"

        # If not found, keep original (might be same-page anchor)
        return match.group(0)

    # Match markdown links [text](url)
    return re.sub(r"\[([^\]]+)\]\(([^)]+)\)", replace_link, content)


def generate_index(
    intro: str,
    modules: list[tuple[str, str, str]]
) -> str:
    """Generate an index.md file with links to all modules."""
    # Extract just the title from front matter if present
    title_match = re.search(r"^---\ntitle:\s*(.+)\n---\n", intro, re.MULTILINE)

    if title_match:
        title = title_match.group(1)
        index_content = f"---\ntitle: {title}\n---\n\n"
    else:
        index_content = "---\ntitle: Python API Reference\n---\n\n"

    # Add a brief introduction
    index_content += "# Python API Reference\n\n"
    index_content += "Auto-generated reference documentation for all Python modules in the LEADR codebase.\n\n"

    # Add module links
    index_content += "## Modules\n\n"

    for module_name, slug, _ in sorted(modules, key=lambda x: x[0]):
        # Extract just the module part after "leadr."
        display_name = module_name.replace("leadr.", "")
        index_content += f"- **[{display_name}](./{slug}.md)** - `{module_name}`\n"

    return index_content


def split_reference(input_file: Path, output_dir: Path) -> None:
    """Split Python reference documentation into multiple files."""
    # Read input file
    content = input_file.read_text()

    # Parse modules
    intro, modules = parse_modules(content)

    if not modules:
        print("Warning: No modules found to split. Creating single index file.")
        output_dir.mkdir(parents=True, exist_ok=True)
        (output_dir / "index.md").write_text(intro)
        return

    # Build anchor map for link rewriting
    anchor_map = build_anchor_map(modules)

    # Create output directory
    output_dir.mkdir(parents=True, exist_ok=True)

    # Write each module to its own file
    for module_name, slug, module_content in modules:
        # Rewrite links in this module
        rewritten_content = rewrite_links(module_content, anchor_map)

        # Write to file
        output_file = output_dir / f"{slug}.md"
        output_file.write_text(rewritten_content)
        print(f"  Created {output_file}")

    # Generate and write index
    index_content = generate_index(intro, modules)
    index_file = output_dir / "index.md"
    index_file.write_text(index_content)
    print(f"  Created {index_file}")


def main():
    """Main entry point."""
    if len(sys.argv) != 3:
        print("Usage: split_reference.py <input_file> <output_dir>")
        sys.exit(1)

    input_file = Path(sys.argv[1])
    output_dir = Path(sys.argv[2])

    if not input_file.exists():
        print(f"Error: Input file not found: {input_file}")
        sys.exit(1)

    print(f"Splitting {input_file} into {output_dir}/")
    split_reference(input_file, output_dir)
    print("Python reference documentation split successfully!")


if __name__ == "__main__":
    main()
